<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ava's Rat Trap: Mobile Optimized</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #222;
            --text-color: #33ff00;
            --accent-color: #ff3333;
            --rat-color: #ffcc00;
            --ui-font: 'Press Start 2P', cursive;
            /* DYNAMIC SIZES (Set via JS) */
            --entity-size: 40px; 
            --emoji-size: 50px;
        }

        body {
            margin: 0; padding: 0; background-color: var(--bg-color); color: var(--text-color);
            font-family: var(--ui-font); overflow: hidden; touch-action: manipulation;
            user-select: none; cursor: crosshair;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; padding: 10px;
            box-sizing: border-box; display: flex; justify-content: space-between;
            pointer-events: none; z-index: 50; text-shadow: 2px 2px #000;
            font-size: 10px; /* Smaller text on mobile */
        }

        /* TUG BAR */
        #tug-container {
            position: absolute; top: 35px; left: 50%; transform: translateX(-50%);
            width: 60%; height: 15px; 
            border: 2px solid #fff; 
            background: var(--accent-color);
            z-index: 50; border-radius: 4px; overflow: hidden;
        }
        #tug-bar {
            width: 50%; height: 100%; background: var(--text-color); transition: width 0.2s;
        }
        #center-marker {
            position: absolute; top: 0; bottom: 0; left: 50%; width: 2px; background: #000;
        }
        #timer-display {
            position: absolute; top: 55px; left: 50%; transform: translateX(-50%);
            font-size: 10px; color: #fff; z-index: 50;
        }

        /* INVENTORY */
        #inventory-container {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; z-index: 50;
        }
        .inv-slot {
            width: 40px; height: 40px; border: 2px solid #555; background: rgba(0,0,0,0.5);
            display: flex; align-items: center; justify-content: center; font-size: 20px;
            cursor: default; transition: 0.2s;
        }
        .inv-slot.filled {
            border-color: #ffcc00; cursor: pointer; box-shadow: 0 0 10px #ffcc00; animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        #game-area { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }

        /* BUNKERS */
        .bunker {
            position: absolute; transform: translate(-50%, -50%);
            border: 2px solid #00ff00; border-radius: 50%; background: #2a2a2a;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-size: 8px; color: #fff; text-align: center;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.1);
            transition: border-color 0.2s;
        }
        .bunker-count { font-size: 10px; color: #00ffff; margin-top: 2px; font-weight: bold; }
        .bunker.full { border-color: #ff0000 !important; background: #330000; }

        /* ENTITIES */
        .entity {
            position: absolute; 
            font-size: var(--entity-size); /* Scaled via JS */
            transform: translate(-50%, -50%);
            transition: transform 0.1s linear, opacity 0.2s; 
            user-select: none; display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 5;
        }
        .rat { font-size: var(--emoji-size); cursor: crosshair; }
        .cat { font-size: var(--emoji-size); pointer-events: none; z-index: 6; }

        /* BARS */
        .bars-container { position: absolute; top: -10px; display: flex; flex-direction: column; gap: 1px; pointer-events: none; }
        .bar-bg { width: 25px; height: 3px; background: #000; border: 1px solid #fff; }
        .hunger-fill { width: 100%; height: 100%; background-color: #00ff00; transition: width 0.2s; }
        .spawn-fill { width: 0%; height: 100%; background-color: #00ffff; transition: width 0.1s linear; }

        .expiring { animation: blink 0.5s infinite; color: #ff00ff; }
        @keyframes blink { 0% { opacity: 1; } 50% { opacity: 0.4; } 100% { opacity: 1; } }

        /* SCREENS */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 100; text-align: center;
            padding: 20px; box-sizing: border-box;
        }
        button {
            background: var(--text-color); color: #000; border: 4px solid #fff;
            padding: 15px 20px; font-family: var(--ui-font); font-size: 14px;
            margin-top: 20px; cursor: pointer; text-transform: uppercase;
        }
        .hidden { display: none !important; }
        
        .floater {
            position: absolute; font-weight: bold; pointer-events: none;
            animation: floatUp 1s forwards; font-family: var(--ui-font);
            z-index: 100; text-shadow: 2px 2px 0 #000; font-size: 12px;
        }
        @keyframes floatUp { 0% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-50px); } }
        .shake { animation: shake 0.5s; }
        @keyframes shake { 0% { transform: translate(1px, 1px) rotate(0deg); } 50% { transform: translate(-1px, 2px) rotate(-1deg); } 100% { transform: translate(1px, -2px) rotate(-1deg); } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-box" style="color: #888;">VS</div>
        <div class="stat-box" style="text-align: right; color: #ffcc00;">NET: <span id="net-display">15</span></div>
    </div>

    <div id="tug-container">
        <div id="center-marker"></div>
        <div id="tug-bar"></div>
    </div>
    <div id="timer-display">TIME: 0.0s</div>

    <div id="inventory-container">
        <div id="slot-0" class="inv-slot" onclick="deployCat(0)"></div>
        <div id="slot-1" class="inv-slot" onclick="deployCat(1)"></div>
        <div id="slot-2" class="inv-slot" onclick="deployCat(2)"></div>
    </div>

    <div id="start-screen" class="screen">
        <h1 style="color: var(--text-color); margin-bottom: 10px; font-size: 20px;">AVA'S RAT TRAP</h1>
        <p style="font-size: 10px; line-height: 1.6;">
            TAP RATS (+1 Score)<br>
            AVOID BOMBS<br>
            <br>
            <span style="color:#00ffff">MOBILE EDITION:</span><br>
            Smaller bunkers.<br>
            Slower rats.
        </p>
        <button onclick="startGame()">START GAME</button>
    </div>

    <div id="win-screen" class="screen hidden">
        <h1 style="color: #00ff00;">VICTORY!</h1>
        <p>TIME: <span id="win-time">0</span>s</p>
        <button onclick="startGame()">PLAY AGAIN</button>
    </div>

    <div id="lose-screen" class="screen hidden">
        <h1 style="color: #ff3333;">DEFEATED!</h1>
        <p id="lose-reason">RATS TOOK OVER</p>
        <button onclick="startGame()">TRY AGAIN</button>
    </div>

    <div id="game-area"></div>

    <script>
        // --- 1. DETECT SCREEN SIZE & SET SCALAR ---
        const isMobile = window.innerWidth < 600;
        const S = isMobile ? 0.55 : 1.0; // Scale factor (55% size on mobile)

        // Inject CSS variables for fonts
        document.documentElement.style.setProperty('--entity-size', (40 * S) + 'px');
        document.documentElement.style.setProperty('--emoji-size', (50 * S) + 'px');

        const GAME_CONFIG = {
            ASSETS: { RAT: 'ðŸ€', CAT: 'ðŸ¯', CHEESE: 'ðŸ§€', BOMB: 'ðŸ’£', SPLAT: 'ðŸ¦ ', EXPLOSION: 'ðŸ’¥' },
            PLAYER: { START_HEALTH: 15, MAX_CATS_INVENTORY: 3, POINTS_PER_CAT: 10 },
            TUG_OF_WAR: { START: 50, WIN: 100, LOSE: 0, PLAYER_PUSH: 2, RAT_PUSH: 4 },
            RAT: {
                MAX_ON_SCREEN: 20, 
                START_SPEED: 1.0, // Slower for mobile
                SPEED_INCREASE: 0.0, CHEESE_BOOST: 0.5, MAX_SPEED: 6.0, MIN_SPEED: 0.5, 
                SIZE: 50 * S, // Scaled
                START_HUNGER: 10, MAX_HUNGER: 10,
                BUNKER_HUNGER_MULTI: 0.5, VISION_RANGE: 300 * S, BASE_FEAR: 1.5, BASE_HUNGER_PULL: 0.5, 
                NEST_MULTIPLY_TIME: 5000, TUNNEL_CHANCE: 0.5 
            },
            CAT: {
                MAX_ON_SCREEN: 3, START_SPEED: 0.8, SPEED_INCREASE: 0.3, MAX_SPEED: 5.0, MIN_SPEED: 0.3,
                SIZE: 50 * S, // Scaled
                START_HUNGER: 10, MAX_HUNGER: 10, HUNGER_SPEED_MULTI: 0.5
            },
            ITEMS: {
                BOMB_DAMAGE: 3, MISS_DAMAGE: 1, CHEESE_DAMAGE: 1, SPLAT_DAMAGE: 1,
                SPLAT_SLOW: 0.5, DESPAWN_TIME: 8000, WARN_TIME: 5000
            },
            SPAWN: {
                HAZARD_INTERVAL: 3500, BOMB_WEIGHT: 60, SPLAT_WEIGHT: 40,
                CHEESE_BASE_INTERVAL: 1500, CHEESE_MIN_INTERVAL: 400, CHEESE_CATCHUP_MS: 15 
            },
            HUNGER: { DECAY_RATE: 1500, FOOD_RESTORE: 2 },
            // SCALED BUNKERS
            BUNKERS: [
                { id: 'alpha', radius: 100 * S, capacity: 10, label: "ALPHA" },
                { id: 'beta', radius: 70 * S, capacity: 5, label: "BETA" },
                { id: 'gamma', radius: 50 * S, capacity: 2, label: "GAMMA" }
            ]
        };

        // --- GAME VARIABLES ---
        let tugValue = 50; 
        let progressSinceLastCat = 0;
        let netHealth = GAME_CONFIG.PLAYER.START_HEALTH;
        let gameActive = false;
        let totalGameTime = 0;
        
        let cheeseTimer = 0;
        let hazardTimer = 0;
        let hungerTimer = 0;

        let catsInInventory = 0;
        let deployedCats = [];
        let activeRats = []; 
        let activeBunkers = [];
        
        const ENTITY_SIZE = 40 * S; // Scaled entity size for calc
        
        const gameArea = document.getElementById('game-area');
        const netDisplay = document.getElementById('net-display');
        const tugBar = document.getElementById('tug-bar');
        const timerDisplay = document.getElementById('timer-display');
        
        const startScreen = document.getElementById('start-screen');
        const winScreen = document.getElementById('win-screen');
        const loseScreen = document.getElementById('lose-screen');
        
        const winTimeDisplay = document.getElementById('win-time');
        const loseReasonDisplay = document.getElementById('lose-reason');
        
        const slots = [document.getElementById('slot-0'), document.getElementById('slot-1'), document.getElementById('slot-2')];

        // --- UTILITY FUNCTIONS ---

        function showFloatingText(x, y, text, color) {
            const el = document.createElement('div');
            el.classList.add('floater');
            el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.color = color; el.innerText = text;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }

        function updateBarVisuals(barElement, current, max, color) {
            if (!barElement) return;
            const pct = Math.max(0, (current / max) * 100);
            barElement.style.width = pct + '%';
            if (pct > 50) barElement.style.backgroundColor = color;
            else if (pct > 25) barElement.style.backgroundColor = '#ffff00';
            else barElement.style.backgroundColor = '#ff0000';
        }

        function getBunkerAt(x, y) {
            for (let b of activeBunkers) {
                const dx = x - b.x, dy = y - b.y;
                if (Math.sqrt(dx*dx + dy*dy) < b.radius) return b;
            }
            return null;
        }

        function getRandomBunker(excludeBunker) {
            const available = activeBunkers.filter(b => b !== excludeBunker);
            if (available.length === 0) return excludeBunker; 
            return available[Math.floor(Math.random() * available.length)];
        }

        function killRat(rat) {
            rat.dead = true; 
            if (rat.element) rat.element.style.display = 'none'; 
        }

        function cleanUpDeadEntities() {
            for (let i = activeRats.length - 1; i >= 0; i--) {
                if (activeRats[i].dead) {
                    if(activeRats[i].element) activeRats[i].element.remove();
                    activeRats.splice(i, 1);
                }
            }
            for (let i = deployedCats.length - 1; i >= 0; i--) {
                if (deployedCats[i].dead) {
                    if(deployedCats[i].element) deployedCats[i].element.remove();
                    deployedCats.splice(i, 1);
                }
            }
            if (activeRats.length === 0 && gameActive) createRat();
        }

        // --- CORE FUNCTIONS ---

        function startGame() {
            tugValue = GAME_CONFIG.TUG_OF_WAR.START;
            netHealth = GAME_CONFIG.PLAYER.START_HEALTH;
            progressSinceLastCat = 0;
            totalGameTime = 0;
            catsInInventory = 0;
            deployedCats = []; 
            activeRats = []; 
            cheeseTimer = 0;
            hazardTimer = 0;
            hungerTimer = 0;
            gameActive = true;
            
            const entities = document.querySelectorAll('.entity');
            entities.forEach(e => e.remove());
            const oldBunkers = document.querySelectorAll('.bunker');
            oldBunkers.forEach(e => e.remove());

            setupBunkers();
            updateUI();
            updateInventoryUI();
            
            startScreen.classList.add('hidden');
            winScreen.classList.add('hidden');
            loseScreen.classList.add('hidden');

            createRat(); 
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        }

        function updateTugOfWar(amount) {
            tugValue += amount;
            tugValue = Math.max(0, Math.min(100, tugValue));
            
            if (amount > 0) {
                progressSinceLastCat += amount;
                if (progressSinceLastCat >= (GAME_CONFIG.PLAYER.POINTS_PER_CAT * GAME_CONFIG.TUG_OF_WAR.PLAYER_PUSH)) {
                    if (catsInInventory < GAME_CONFIG.PLAYER.MAX_CATS_INVENTORY) {
                        catsInInventory++;
                        progressSinceLastCat = 0;
                        showFloatingText(window.innerWidth/2, window.innerHeight - 100, "CAT EARNED!", "#ffcc00");
                        updateInventoryUI();
                    }
                }
            }
            updateUI();
            if (tugValue >= GAME_CONFIG.TUG_OF_WAR.WIN) gameWin();
            else if (tugValue <= GAME_CONFIG.TUG_OF_WAR.LOSE) gameLose("OVERRUN BY RATS");
        }

        function setupBunkers() {
            activeBunkers = [];
            const w = window.innerWidth;
            const h = window.innerHeight;
            const positions = [
                { x: w * 0.2, y: h * 0.25 }, { x: w * 0.8, y: h * 0.25 }, { x: w * 0.5, y: h * 0.75 } 
            ];

            GAME_CONFIG.BUNKERS.forEach((def, index) => {
                const pos = positions[index];
                const el = document.createElement('div');
                el.className = 'bunker';
                el.style.width = (def.radius * 2) + 'px';
                el.style.height = (def.radius * 2) + 'px';
                el.style.left = pos.x + 'px';
                el.style.top = pos.y + 'px';
                el.innerHTML = `<span>${def.label}</span><div class="bunker-count">0/${def.capacity}</div>`;
                gameArea.appendChild(el);

                activeBunkers.push({
                    x: pos.x, y: pos.y, radius: def.radius,
                    capacity: def.capacity, element: el,
                    countElement: el.querySelector('.bunker-count'), occupants: 0
                });
            });
        }

        function createRat(startX, startY) {
            if (activeRats.length >= GAME_CONFIG.RAT.MAX_ON_SCREEN) return;

            const ratEl = document.createElement('div');
            ratEl.classList.add('entity', 'rat');
            const emojiSpan = document.createElement('span');
            emojiSpan.innerText = GAME_CONFIG.ASSETS.RAT; 
            ratEl.appendChild(emojiSpan);

            const barsDiv = document.createElement('div');
            barsDiv.className = 'bars-container';
            const hBarBg = document.createElement('div');
            hBarBg.className = 'bar-bg';
            const hBarFill = document.createElement('div');
            hBarFill.className = 'hunger-fill';
            hBarBg.appendChild(hBarFill);
            barsDiv.appendChild(hBarBg);
            const sBarBg = document.createElement('div');
            sBarBg.className = 'bar-bg';
            const sBarFill = document.createElement('div');
            sBarFill.className = 'spawn-fill';
            sBarBg.appendChild(sBarFill);
            barsDiv.appendChild(sBarBg);
            ratEl.appendChild(barsDiv);

            gameArea.appendChild(ratEl);
            
            let x = startX, y = startY;
            if (x === undefined) {
                let safe = false, tries = 0;
                while(!safe && tries < 10) {
                    x = Math.random() * (window.innerWidth - GAME_CONFIG.RAT.SIZE);
                    y = Math.random() * (window.innerHeight - GAME_CONFIG.RAT.SIZE);
                    const bunk = getBunkerAt(x, y);
                    if (!bunk || bunk.occupants < bunk.capacity) safe = true;
                    tries++;
                }
            }

            const ratObj = {
                x: x, y: y, element: ratEl, 
                hunger: GAME_CONFIG.RAT.START_HUNGER, speed: GAME_CONFIG.RAT.START_SPEED, 
                hungerBar: hBarFill, spawnBar: sBarFill,
                dirX: (Math.random() * 2) - 1, dirY: (Math.random() * 2) - 1,
                nestTimer: 0, currentBunker: null, dead: false
            };
            
            ratEl.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                attemptCatchRat(ratObj, e.clientX, e.clientY);
            });
            ratEl.addEventListener('touchstart', (e) => { 
                e.stopPropagation(); e.preventDefault(); 
                attemptCatchRat(ratObj, e.touches[0].clientX, e.touches[0].clientY);
            });

            activeRats.push(ratObj);
            updateBarVisuals(ratObj.hungerBar, ratObj.hunger, GAME_CONFIG.RAT.MAX_HUNGER, '#00ff00');
        }

        function attemptCatchRat(ratObj, x, y) {
            if (!gameActive || ratObj.dead) return;
            if (ratObj.currentBunker) {
                showFloatingText(x, y, "SAFE!", "#888");
                damageNet(1, x, y); 
                return; 
            }
            killRat(ratObj);
            handleSuccessfulCatch(x, y);
        }

        function handleSuccessfulCatch(x, y) {
            updateTugOfWar(GAME_CONFIG.TUG_OF_WAR.PLAYER_PUSH);
            showFloatingText(x, y, "CAUGHT!", "#33ff00");
        }

        function updateBunkers() {
            activeBunkers.forEach(b => b.occupants = 0);
            activeRats.forEach(r => {
                if (!r.dead && r.currentBunker) r.currentBunker.occupants++;
            });
            activeBunkers.forEach(b => {
                b.countElement.innerText = `${b.occupants}/${b.capacity}`;
                if (b.occupants >= b.capacity) b.element.classList.add('full');
                else b.element.classList.remove('full');
            });
        }

        function handleSpawning(dt) {
            let advantage = Math.max(0, tugValue - 50); 
            let speedUp = advantage * GAME_CONFIG.SPAWN.CHEESE_CATCHUP_MS;
            let currentCheeseInterval = Math.max(GAME_CONFIG.SPAWN.CHEESE_MIN_INTERVAL, GAME_CONFIG.SPAWN.CHEESE_BASE_INTERVAL - speedUp);

            cheeseTimer += dt;
            if (cheeseTimer > currentCheeseInterval) {
                cheeseTimer = 0;
                spawnEntity(GAME_CONFIG.ASSETS.CHEESE, 'cheese');
            }

            hazardTimer += dt;
            if (hazardTimer > GAME_CONFIG.SPAWN.HAZARD_INTERVAL) {
                hazardTimer = 0;
                let bombWeight = GAME_CONFIG.SPAWN.BOMB_WEIGHT;
                let splatWeight = GAME_CONFIG.SPAWN.SPLAT_WEIGHT;
                let total = bombWeight + splatWeight;
                let roll = Math.random() * total;
                if (roll < bombWeight) spawnEntity(GAME_CONFIG.ASSETS.BOMB, 'bomb');
                else spawnEntity(GAME_CONFIG.ASSETS.SPLAT, 'splat');
            }
        }

        function spawnEntity(emoji, type) {
            let x, y, safe = false, tries = 0;
            while(!safe && tries < 20) {
                x = Math.random() * (window.innerWidth - ENTITY_SIZE);
                y = Math.random() * (window.innerHeight - ENTITY_SIZE);
                if (!getBunkerAt(x, y)) safe = true;
                tries++;
            }

            const el = document.createElement('div');
            el.classList.add('entity');
            el.innerText = emoji;
            el.dataset.type = type;
            el.style.left = x + 'px';
            el.style.top = y + 'px';

            const hitHandler = (e) => {
                e.stopPropagation();
                if(e.type === 'touchstart') e.preventDefault();
                if (type === 'bomb') damageNet(GAME_CONFIG.ITEMS.BOMB_DAMAGE, e.clientX, e.clientY);
                else if (type === 'cheese') damageNet(GAME_CONFIG.ITEMS.CHEESE_DAMAGE, e.clientX, e.clientY);
                else if (type === 'splat') damageNet(GAME_CONFIG.ITEMS.SPLAT_DAMAGE, e.clientX, e.clientY);
                el.remove();
            };
            el.addEventListener('click', hitHandler);
            el.addEventListener('touchstart', hitHandler);
            gameArea.appendChild(el);

            setTimeout(() => { if (el.parentElement) el.classList.add('expiring'); }, GAME_CONFIG.ITEMS.WARN_TIME);
            setTimeout(() => { if (el.parentElement) el.remove(); }, GAME_CONFIG.ITEMS.DESPAWN_TIME);
        }

        function damageNet(amount, x, y) {
            if(!x) x = window.innerWidth/2;
            if(!y) y = window.innerHeight/2;
            netHealth -= amount;
            showFloatingText(x, y, `-${amount}`, "#ff3333");
            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 500);
            if (netHealth <= 0) gameLose("NET BROKEN");
            updateUI();
        }

        function updateInventoryUI() {
            slots.forEach((slot, index) => {
                if (index < catsInInventory) {
                    slot.innerText = GAME_CONFIG.ASSETS.CAT;
                    slot.classList.add('filled');
                } else {
                    slot.innerText = '';
                    slot.classList.remove('filled');
                }
            });
        }

        function deployCat(index) {
            if (!gameActive || index >= catsInInventory) return;
            if (deployedCats.length >= GAME_CONFIG.CAT.MAX_ON_SCREEN) {
                showFloatingText(window.innerWidth/2, window.innerHeight - 100, "MAX CATS!", "#ff0000");
                return;
            }
            catsInInventory--;
            updateInventoryUI();

            const catEl = document.createElement('div');
            catEl.classList.add('entity', 'cat');
            const emojiSpan = document.createElement('span');
            emojiSpan.innerText = GAME_CONFIG.ASSETS.CAT;
            catEl.appendChild(emojiSpan);
            const barsDiv = document.createElement('div');
            barsDiv.className = 'bars-container';
            const hBarBg = document.createElement('div');
            hBarBg.className = 'bar-bg';
            const hBarFill = document.createElement('div');
            hBarFill.className = 'hunger-fill';
            hBarBg.appendChild(hBarFill);
            barsDiv.appendChild(hBarBg);
            catEl.appendChild(barsDiv);
            gameArea.appendChild(catEl);

            deployedCats.push({
                x: window.innerWidth / 2, y: window.innerHeight / 2,
                element: catEl, speed: GAME_CONFIG.CAT.START_SPEED,
                hunger: GAME_CONFIG.CAT.START_HUNGER, hungerBar: hBarFill, dead: false
            });
        }

        // --- GAME LOOP ---

        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!gameActive) return;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            totalGameTime += deltaTime;
            timerDisplay.innerText = "TIME: " + (totalGameTime / 1000).toFixed(1) + "s";

            handleSpawning(deltaTime);
            hungerTimer += deltaTime;
            if (hungerTimer >= GAME_CONFIG.HUNGER.DECAY_RATE) {
                applyHungerTick();
                hungerTimer = 0;
            }

            activeBunkers.forEach(b => b.occupants = 0);
            activeRats.forEach(r => { if(!r.dead && r.currentBunker) r.currentBunker.occupants++; });

            moveRatsAI(deltaTime);
            updateBunkers(); 
            moveCats();
            checkRatCollisions();
            cleanUpDeadEntities();

            requestAnimationFrame(gameLoop);
        }

        function applyHungerTick() {
            activeRats.forEach(r => {
                if(r.dead) return;
                let decay = r.currentBunker ? GAME_CONFIG.RAT.BUNKER_HUNGER_MULTI : 1; 
                r.hunger -= decay;
                updateBarVisuals(r.hungerBar, r.hunger, GAME_CONFIG.RAT.MAX_HUNGER, '#00ff00');
                if (r.hunger <= 0) {
                    showFloatingText(r.x, r.y, "STARVED!", "#888");
                    killRat(r);
                }
            });
            deployedCats.forEach(cat => {
                if(cat.dead) return;
                cat.hunger--;
                updateBarVisuals(cat.hungerBar, cat.hunger, GAME_CONFIG.CAT.MAX_HUNGER, '#00ff00');
                if (cat.hunger <= 0) {
                    showFloatingText(window.innerWidth/2, window.innerHeight/2, "CAT LEFT!", "#ffcc00");
                    cat.dead = true;
                    if(cat.element) cat.element.style.display = 'none';
                }
            });
        }

        function moveRatsAI(dt) {
            activeRats.forEach(rat => {
                if (rat.dead || !rat.element) return;

                if (rat.currentBunker) {
                    rat.element.style.opacity = '0';
                    rat.nestTimer += dt;
                    const spawnPct = (rat.nestTimer / GAME_CONFIG.RAT.NEST_MULTIPLY_TIME) * 100;
                    if(rat.spawnBar) rat.spawnBar.style.width = spawnPct + '%';

                    if (rat.nestTimer > GAME_CONFIG.RAT.NEST_MULTIPLY_TIME) {
                        rat.nestTimer = 0;
                        if(rat.spawnBar) rat.spawnBar.style.width = '0%';
                        
                        // 1. BREED CHECK (EJECTION)
                        if (activeRats.length < GAME_CONFIG.RAT.MAX_ON_SCREEN) {
                            const angle = Math.random() * Math.PI * 2;
                            const bx = rat.currentBunker.x + Math.cos(angle) * (rat.currentBunker.radius + 15);
                            const by = rat.currentBunker.y + Math.sin(angle) * (rat.currentBunker.radius + 15);
                            createRat(bx, by); 
                            showFloatingText(rat.currentBunker.x, rat.currentBunker.y, "MULTIPLIED!", "#00ffff");
                        } else {
                            showFloatingText(rat.currentBunker.x, rat.currentBunker.y, "MAX RATS!", "#ff0000");
                        }

                        // 2. TUNNEL CHECK
                        if (Math.random() < GAME_CONFIG.RAT.TUNNEL_CHANCE) {
                            const exitBunker = getRandomBunker(rat.currentBunker);
                            if(exitBunker) {
                                const angle = Math.random() * Math.PI * 2;
                                rat.x = exitBunker.x + Math.cos(angle) * (exitBunker.radius + 15);
                                rat.y = exitBunker.y + Math.sin(angle) * (exitBunker.radius + 15);
                                rat.currentBunker = null; 
                                rat.element.style.opacity = '1';
                                showFloatingText(exitBunker.x, exitBunker.y, "TUNNEL!", "#ff00ff");
                            }
                        }
                    }
                } else {
                    rat.element.style.opacity = '1';
                    rat.nestTimer = 0;
                    if(rat.spawnBar) rat.spawnBar.style.width = '0%';
                }

                let moveX = 0;
                let moveY = 0;
                const isHungry = rat.hunger < 5;
                const cheesePullStrength = isHungry ? 2.0 : 0.5;

                const cheeseElements = document.querySelectorAll('[data-type="cheese"]');
                let nearestCheese = null, minCheeseDist = Infinity;
                cheeseElements.forEach(cheese => {
                    const cx = parseFloat(cheese.style.left);
                    const cy = parseFloat(cheese.style.top);
                    const d = Math.sqrt((cx - rat.x)**2 + (cy - rat.y)**2);
                    if (d < minCheeseDist) { minCheeseDist = d; nearestCheese = {x: cx, y: cy}; }
                });
                if (nearestCheese && isHungry) {
                    moveX += ((nearestCheese.x - rat.x) / minCheeseDist) * cheesePullStrength;
                    moveY += ((nearestCheese.y - rat.y) / minCheeseDist) * cheesePullStrength;
                }

                if (!isHungry) {
                    let nearestBunker = null, minBunkerDist = Infinity;
                    activeBunkers.forEach(b => {
                        if (b.occupants < b.capacity || rat.currentBunker === b) {
                            const d = Math.sqrt((b.x - rat.x)**2 + (b.y - rat.y)**2);
                            if (d < minBunkerDist) { minBunkerDist = d; nearestBunker = b; }
                        }
                    });
                    if (nearestBunker) {
                        moveX += ((nearestBunker.x - rat.x) / minBunkerDist) * 1.5;
                        moveY += ((nearestBunker.y - rat.y) / minBunkerDist) * 1.5;
                    }
                }

                deployedCats.forEach(cat => {
                    if (cat.dead) return;
                    const dx = rat.x - cat.x, dy = rat.y - cat.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < GAME_CONFIG.RAT.VISION_RANGE) {
                        const strength = (GAME_CONFIG.RAT.VISION_RANGE - dist) / GAME_CONFIG.RAT.VISION_RANGE;
                        moveX += (dx / dist) * strength * GAME_CONFIG.RAT.BASE_FEAR;
                        moveY += (dy / dist) * strength * GAME_CONFIG.RAT.BASE_FEAR;
                    }
                });

                if (Math.random() < 0.05) { rat.dirX += (Math.random() - 0.5); rat.dirY += (Math.random() - 0.5); }
                moveX += rat.dirX * 0.5; moveY += rat.dirY * 0.5;

                const finalDist = Math.sqrt(moveX*moveX + moveY*moveY);
                if (finalDist > 0) {
                    moveX = (moveX / finalDist) * rat.speed;
                    moveY = (moveY / finalDist) * rat.speed;
                }

                let nextX = rat.x + moveX;
                let nextY = rat.y + moveY;

                activeBunkers.forEach(b => {
                    const dist = Math.sqrt((nextX - b.x)**2 + (nextY - b.y)**2);
                    if (dist < b.radius) {
                        if (rat.currentBunker !== b) {
                            if (b.occupants >= b.capacity) {
                                const angle = Math.atan2(nextY - b.y, nextX - b.x);
                                nextX = b.x + Math.cos(angle) * (b.radius + 2);
                                nextY = b.y + Math.sin(angle) * (b.radius + 2);
                                rat.dirX *= -1; rat.dirY *= -1;
                            } else {
                                b.occupants++; rat.currentBunker = b;
                            }
                        }
                    } else {
                        if (rat.currentBunker === b) {
                            rat.currentBunker = null; b.occupants--;
                        }
                    }
                });

                rat.x = nextX; rat.y = nextY;
                if (rat.x < 0 || rat.x > window.innerWidth - 50) { rat.x = Math.max(0, Math.min(rat.x, window.innerWidth-50)); rat.dirX *= -1; }
                if (rat.y < 0 || rat.y > window.innerHeight - 50) { rat.y = Math.max(0, Math.min(rat.y, window.innerHeight-50)); rat.dirY *= -1; }

                rat.element.style.left = rat.x + 'px';
                rat.element.style.top = rat.y + 'px';
                
                if (Math.abs(moveX) > 0.1) {
                    const emoji = rat.element.children[0];
                    if(emoji) emoji.style.transform = `scaleX(${moveX > 0 ? -1 : 1})`;
                }
            });
        }

        function moveCats() {
            deployedCats.forEach(cat => {
                if(cat.dead || !cat.element) return;

                let hungerRatio = cat.hunger / GAME_CONFIG.CAT.MAX_HUNGER;
                let currentBoost = 1 + ((1 - hungerRatio) * GAME_CONFIG.CAT.HUNGER_SPEED_MULTI);
                let effectiveSpeed = cat.speed * currentBoost;

                let nearestRat = null, minDist = Infinity;
                activeRats.forEach(r => {
                    if (r.currentBunker || r.dead) return; 
                    const d = Math.sqrt((r.x - cat.x)**2 + (r.y - cat.y)**2);
                    if (d < minDist) { minDist = d; nearestRat = r; }
                });

                if (nearestRat && minDist > 5) {
                    const dx = nearestRat.x - cat.x;
                    const dy = nearestRat.y - cat.y;
                    cat.x += (dx / minDist) * effectiveSpeed;
                    cat.y += (dy / minDist) * effectiveSpeed;
                }

                // Force Fields
                activeBunkers.forEach(b => {
                    const dist = Math.sqrt((cat.x - b.x)**2 + (cat.y - b.y)**2);
                    const minDist = b.radius + 25; 
                    if (dist < minDist) {
                        const angle = Math.atan2(cat.y - b.y, cat.x - b.x);
                        cat.x = b.x + Math.cos(angle) * minDist;
                        cat.y = b.y + Math.sin(angle) * minDist;
                    }
                });

                cat.element.style.left = cat.x + 'px';
                cat.element.style.top = cat.y + 'px';

                // Catch logic
                activeRats.forEach(r => {
                    if (r.dead || r.currentBunker) return;
                    let d = Math.sqrt((r.x - cat.x)**2 + (r.y - cat.y)**2);
                    if (d < (GAME_CONFIG.RAT.SIZE/2 + GAME_CONFIG.CAT.SIZE/2)) {
                        cat.speed = Math.min(cat.speed + GAME_CONFIG.CAT.SPEED_INCREASE, GAME_CONFIG.CAT.MAX_SPEED);
                        cat.hunger = Math.min(cat.hunger + GAME_CONFIG.HUNGER.FOOD_RESTORE, GAME_CONFIG.CAT.MAX_HUNGER);
                        updateBarVisuals(cat.hungerBar, cat.hunger, GAME_CONFIG.CAT.MAX_HUNGER, '#00ff00');
                        showFloatingText(cat.x, cat.y, "NOM!", "#ffcc00");
                        killRat(r);
                        handleSuccessfulCatch(cat.x, cat.y);
                    }
                });

                // Items
                const catRect = cat.element.getBoundingClientRect();
                document.querySelectorAll('.entity:not(.rat):not(.cat)').forEach(entity => {
                    if(!entity.parentNode) return;
                    const rect = entity.getBoundingClientRect();
                    if (catRect.left < rect.right && catRect.right > rect.left &&
                        catRect.top < rect.bottom && catRect.bottom > rect.top) {
                        const type = entity.dataset.type;
                        if (type === 'bomb') {
                            entity.remove();
                            cat.element.innerHTML = `<span>${GAME_CONFIG.ASSETS.EXPLOSION}</span>`;
                            cat.dead = true;
                            setTimeout(() => { if(cat.element) cat.element.style.display='none'; }, 200);
                            showFloatingText(cat.x, cat.y, "RIP CAT", "#ff3333");
                        } else if (type === 'splat') {
                            entity.remove();
                            cat.speed = Math.max(cat.speed - GAME_CONFIG.ITEMS.SPLAT_SLOW, GAME_CONFIG.CAT.MIN_SPEED);
                            showFloatingText(cat.x, cat.y, "STUCK!", "#00ffff");
                        }
                    }
                });
            });
        }

        function checkRatCollisions() {
            const items = document.querySelectorAll('.entity:not(.rat):not(.cat)');
            activeRats.forEach(rat => {
                if (rat.dead || !rat.element) return;
                const ratRect = rat.element.getBoundingClientRect();
                items.forEach(item => {
                    if(!item.parentNode) return; 
                    const rect = item.getBoundingClientRect();
                    if (ratRect.left < rect.right && ratRect.right > rect.left &&
                        ratRect.top < rect.bottom && ratRect.bottom > rect.top) {
                        const type = item.dataset.type;
                        if (type === 'cheese') {
                            item.remove();
                            rat.speed = Math.min(rat.speed + GAME_CONFIG.RAT.CHEESE_BOOST, GAME_CONFIG.RAT.MAX_SPEED);
                            rat.hunger = Math.min(rat.hunger + GAME_CONFIG.HUNGER.FOOD_RESTORE, GAME_CONFIG.RAT.MAX_HUNGER);
                            updateBarVisuals(rat.hungerBar, rat.hunger, GAME_CONFIG.RAT.MAX_HUNGER, '#00ff00');
                            updateTugOfWar(-GAME_CONFIG.TUG_OF_WAR.RAT_PUSH); 
                            showFloatingText(rat.x, rat.y, "GULP!", "#ff3333");
                        } else if (type === 'splat') {
                            item.remove();
                            rat.speed = Math.max(rat.speed - GAME_CONFIG.ITEMS.SPLAT_SLOW, GAME_CONFIG.RAT.MIN_SPEED);
                            showFloatingText(rat.x, rat.y, "SLOW!", "#00ffff");
                        } else if (type === 'bomb') {
                            item.remove();
                            showFloatingText(rat.x, rat.y, "BOOM!", "#ff3333");
                            killRat(rat);
                        }
                    }
                });
            });
        }

        function updateUI() {
            tugBar.style.width = tugValue + '%';
            netDisplay.innerText = Math.max(0, netHealth);
            if(netHealth <= 5) netDisplay.style.color = '#ff3333';
            else netDisplay.style.color = '#ffcc00';
        }

        function gameWin() {
            gameActive = false;
            document.querySelectorAll('.bunker').forEach(el => el.style.display = 'none');
            winTimeDisplay.innerText = (totalGameTime / 1000).toFixed(1);
            winScreen.classList.remove('hidden');
        }

        function gameLose(reason) {
            gameActive = false;
            document.querySelectorAll('.bunker').forEach(el => el.style.display = 'none');
            loseReasonDisplay.innerText = reason;
            loseScreen.classList.remove('hidden');
        }

        window.addEventListener('resize', () => {});
    </script>
</body>
</html>